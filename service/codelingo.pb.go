// Code generated by protoc-gen-go.
// source: github.com/codelingo/rpc/service/codelingo.proto
// DO NOT EDIT!

/*
Package service is a generated protocol buffer package.

It is generated from these files:
	github.com/codelingo/rpc/service/codelingo.proto

It has these top-level messages:
	Node
	File
	DescribeFactRequest
	DescribeFactReply
	Property
	QueryFromOffsetRequest
	QueryFromOffsetReply
	GenFact
	GenProperty
	ListFactsRequest
	FactList
	Children
	ListLexiconsRequest
	ListLexiconsReply
	LatestClientVersionRequest
	LatestClientVersionReply
*/
package service

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Node struct {
	Uid string `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Node) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

type File struct {
	Filename string `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *File) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type DescribeFactRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Fact    string `protobuf:"bytes,4,opt,name=fact" json:"fact,omitempty"`
}

func (m *DescribeFactRequest) Reset()                    { *m = DescribeFactRequest{} }
func (m *DescribeFactRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactRequest) ProtoMessage()               {}
func (*DescribeFactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DescribeFactRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DescribeFactRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DescribeFactRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DescribeFactRequest) GetFact() string {
	if m != nil {
		return m.Fact
	}
	return ""
}

type DescribeFactReply struct {
	Description string      `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	Examples    string      `protobuf:"bytes,2,opt,name=examples" json:"examples,omitempty"`
	Properties  []*Property `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty"`
}

func (m *DescribeFactReply) Reset()                    { *m = DescribeFactReply{} }
func (m *DescribeFactReply) String() string            { return proto.CompactTextString(m) }
func (*DescribeFactReply) ProtoMessage()               {}
func (*DescribeFactReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DescribeFactReply) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DescribeFactReply) GetExamples() string {
	if m != nil {
		return m.Examples
	}
	return ""
}

func (m *DescribeFactReply) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type QueryFromOffsetRequest struct {
	Lang     string `protobuf:"bytes,1,opt,name=lang" json:"lang,omitempty"`
	Dir      string `protobuf:"bytes,2,opt,name=dir" json:"dir,omitempty"`
	Filename string `protobuf:"bytes,3,opt,name=filename" json:"filename,omitempty"`
	Src      string `protobuf:"bytes,4,opt,name=src" json:"src,omitempty"`
	Start    int64  `protobuf:"varint,5,opt,name=start" json:"start,omitempty"`
	End      int64  `protobuf:"varint,6,opt,name=end" json:"end,omitempty"`
}

func (m *QueryFromOffsetRequest) Reset()                    { *m = QueryFromOffsetRequest{} }
func (m *QueryFromOffsetRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryFromOffsetRequest) ProtoMessage()               {}
func (*QueryFromOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *QueryFromOffsetRequest) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

func (m *QueryFromOffsetRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *QueryFromOffsetRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *QueryFromOffsetRequest) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *QueryFromOffsetRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *QueryFromOffsetRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type QueryFromOffsetReply struct {
	Facts []*GenFact `protobuf:"bytes,1,rep,name=facts" json:"facts,omitempty"`
}

func (m *QueryFromOffsetReply) Reset()                    { *m = QueryFromOffsetReply{} }
func (m *QueryFromOffsetReply) String() string            { return proto.CompactTextString(m) }
func (*QueryFromOffsetReply) ProtoMessage()               {}
func (*QueryFromOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *QueryFromOffsetReply) GetFacts() []*GenFact {
	if m != nil {
		return m.Facts
	}
	return nil
}

type GenFact struct {
	FactName   string                  `protobuf:"bytes,1,opt,name=factName" json:"factName,omitempty"`
	Properties map[string]*GenProperty `protobuf:"bytes,2,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Children   []*GenFact              `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
}

func (m *GenFact) Reset()                    { *m = GenFact{} }
func (m *GenFact) String() string            { return proto.CompactTextString(m) }
func (*GenFact) ProtoMessage()               {}
func (*GenFact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GenFact) GetFactName() string {
	if m != nil {
		return m.FactName
	}
	return ""
}

func (m *GenFact) GetProperties() map[string]*GenProperty {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *GenFact) GetChildren() []*GenFact {
	if m != nil {
		return m.Children
	}
	return nil
}

type GenProperty struct {
	// Types that are valid to be assigned to Value:
	//	*GenProperty_String_
	//	*GenProperty_Int
	//	*GenProperty_Float
	//	*GenProperty_Bool
	Value isGenProperty_Value `protobuf_oneof:"value"`
}

func (m *GenProperty) Reset()                    { *m = GenProperty{} }
func (m *GenProperty) String() string            { return proto.CompactTextString(m) }
func (*GenProperty) ProtoMessage()               {}
func (*GenProperty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isGenProperty_Value interface {
	isGenProperty_Value()
}

type GenProperty_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,oneof"`
}
type GenProperty_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,oneof"`
}
type GenProperty_Float struct {
	Float float32 `protobuf:"fixed32,3,opt,name=float,oneof"`
}
type GenProperty_Bool struct {
	Bool bool `protobuf:"varint,4,opt,name=bool,oneof"`
}

func (*GenProperty_String_) isGenProperty_Value() {}
func (*GenProperty_Int) isGenProperty_Value()     {}
func (*GenProperty_Float) isGenProperty_Value()   {}
func (*GenProperty_Bool) isGenProperty_Value()    {}

func (m *GenProperty) GetValue() isGenProperty_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GenProperty) GetString_() string {
	if x, ok := m.GetValue().(*GenProperty_String_); ok {
		return x.String_
	}
	return ""
}

func (m *GenProperty) GetInt() int64 {
	if x, ok := m.GetValue().(*GenProperty_Int); ok {
		return x.Int
	}
	return 0
}

func (m *GenProperty) GetFloat() float32 {
	if x, ok := m.GetValue().(*GenProperty_Float); ok {
		return x.Float
	}
	return 0
}

func (m *GenProperty) GetBool() bool {
	if x, ok := m.GetValue().(*GenProperty_Bool); ok {
		return x.Bool
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenProperty) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GenProperty_OneofMarshaler, _GenProperty_OneofUnmarshaler, _GenProperty_OneofSizer, []interface{}{
		(*GenProperty_String_)(nil),
		(*GenProperty_Int)(nil),
		(*GenProperty_Float)(nil),
		(*GenProperty_Bool)(nil),
	}
}

func _GenProperty_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GenProperty)
	// value
	switch x := m.Value.(type) {
	case *GenProperty_String_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.String_)
	case *GenProperty_Int:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int))
	case *GenProperty_Float:
		b.EncodeVarint(3<<3 | proto.WireFixed32)
		b.EncodeFixed32(uint64(math.Float32bits(x.Float)))
	case *GenProperty_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("GenProperty.Value has unexpected type %T", x)
	}
	return nil
}

func _GenProperty_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GenProperty)
	switch tag {
	case 1: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &GenProperty_String_{x}
		return true, err
	case 2: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &GenProperty_Int{int64(x)}
		return true, err
	case 3: // value.float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &GenProperty_Float{math.Float32frombits(uint32(x))}
		return true, err
	case 4: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &GenProperty_Bool{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _GenProperty_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GenProperty)
	// value
	switch x := m.Value.(type) {
	case *GenProperty_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *GenProperty_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *GenProperty_Float:
		n += proto.SizeVarint(3<<3 | proto.WireFixed32)
		n += 4
	case *GenProperty_Bool:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListFactsRequest struct {
	Owner   string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ListFactsRequest) Reset()                    { *m = ListFactsRequest{} }
func (m *ListFactsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFactsRequest) ProtoMessage()               {}
func (*ListFactsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListFactsRequest) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ListFactsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListFactsRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type FactList struct {
	Facts map[string]*Children `protobuf:"bytes,1,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FactList) Reset()                    { *m = FactList{} }
func (m *FactList) String() string            { return proto.CompactTextString(m) }
func (*FactList) ProtoMessage()               {}
func (*FactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *FactList) GetFacts() map[string]*Children {
	if m != nil {
		return m.Facts
	}
	return nil
}

type Children struct {
	Child []string `protobuf:"bytes,1,rep,name=child" json:"child,omitempty"`
}

func (m *Children) Reset()                    { *m = Children{} }
func (m *Children) String() string            { return proto.CompactTextString(m) }
func (*Children) ProtoMessage()               {}
func (*Children) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Children) GetChild() []string {
	if m != nil {
		return m.Child
	}
	return nil
}

type ListLexiconsRequest struct {
}

func (m *ListLexiconsRequest) Reset()                    { *m = ListLexiconsRequest{} }
func (m *ListLexiconsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsRequest) ProtoMessage()               {}
func (*ListLexiconsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type ListLexiconsReply struct {
	Lexicons []string `protobuf:"bytes,1,rep,name=lexicons" json:"lexicons,omitempty"`
}

func (m *ListLexiconsReply) Reset()                    { *m = ListLexiconsReply{} }
func (m *ListLexiconsReply) String() string            { return proto.CompactTextString(m) }
func (*ListLexiconsReply) ProtoMessage()               {}
func (*ListLexiconsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListLexiconsReply) GetLexicons() []string {
	if m != nil {
		return m.Lexicons
	}
	return nil
}

type LatestClientVersionRequest struct {
}

func (m *LatestClientVersionRequest) Reset()                    { *m = LatestClientVersionRequest{} }
func (m *LatestClientVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionRequest) ProtoMessage()               {}
func (*LatestClientVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type LatestClientVersionReply struct {
	Version string `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
}

func (m *LatestClientVersionReply) Reset()                    { *m = LatestClientVersionReply{} }
func (m *LatestClientVersionReply) String() string            { return proto.CompactTextString(m) }
func (*LatestClientVersionReply) ProtoMessage()               {}
func (*LatestClientVersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *LatestClientVersionReply) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*Node)(nil), "service.Node")
	proto.RegisterType((*File)(nil), "service.File")
	proto.RegisterType((*DescribeFactRequest)(nil), "service.DescribeFactRequest")
	proto.RegisterType((*DescribeFactReply)(nil), "service.DescribeFactReply")
	proto.RegisterType((*Property)(nil), "service.Property")
	proto.RegisterType((*QueryFromOffsetRequest)(nil), "service.QueryFromOffsetRequest")
	proto.RegisterType((*QueryFromOffsetReply)(nil), "service.QueryFromOffsetReply")
	proto.RegisterType((*GenFact)(nil), "service.GenFact")
	proto.RegisterType((*GenProperty)(nil), "service.GenProperty")
	proto.RegisterType((*ListFactsRequest)(nil), "service.ListFactsRequest")
	proto.RegisterType((*FactList)(nil), "service.FactList")
	proto.RegisterType((*Children)(nil), "service.Children")
	proto.RegisterType((*ListLexiconsRequest)(nil), "service.ListLexiconsRequest")
	proto.RegisterType((*ListLexiconsReply)(nil), "service.ListLexiconsReply")
	proto.RegisterType((*LatestClientVersionRequest)(nil), "service.LatestClientVersionRequest")
	proto.RegisterType((*LatestClientVersionReply)(nil), "service.LatestClientVersionReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CodeLingo service

type CodeLingoClient interface {
	FileFromNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*File, error)
	// Lists available lexicons
	ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error)
	ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error)
	QueryFromOffset(ctx context.Context, in *QueryFromOffsetRequest, opts ...grpc.CallOption) (*QueryFromOffsetReply, error)
	DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error)
}

type codeLingoClient struct {
	cc *grpc.ClientConn
}

func NewCodeLingoClient(cc *grpc.ClientConn) CodeLingoClient {
	return &codeLingoClient{cc}
}

func (c *codeLingoClient) FileFromNode(ctx context.Context, in *Node, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := grpc.Invoke(ctx, "/service.CodeLingo/FileFromNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListLexicons(ctx context.Context, in *ListLexiconsRequest, opts ...grpc.CallOption) (*ListLexiconsReply, error) {
	out := new(ListLexiconsReply)
	err := grpc.Invoke(ctx, "/service.CodeLingo/ListLexicons", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) ListFacts(ctx context.Context, in *ListFactsRequest, opts ...grpc.CallOption) (*FactList, error) {
	out := new(FactList)
	err := grpc.Invoke(ctx, "/service.CodeLingo/ListFacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) QueryFromOffset(ctx context.Context, in *QueryFromOffsetRequest, opts ...grpc.CallOption) (*QueryFromOffsetReply, error) {
	out := new(QueryFromOffsetReply)
	err := grpc.Invoke(ctx, "/service.CodeLingo/QueryFromOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) DescribeFact(ctx context.Context, in *DescribeFactRequest, opts ...grpc.CallOption) (*DescribeFactReply, error) {
	out := new(DescribeFactReply)
	err := grpc.Invoke(ctx, "/service.CodeLingo/DescribeFact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeLingoClient) LatestClientVersion(ctx context.Context, in *LatestClientVersionRequest, opts ...grpc.CallOption) (*LatestClientVersionReply, error) {
	out := new(LatestClientVersionReply)
	err := grpc.Invoke(ctx, "/service.CodeLingo/LatestClientVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CodeLingo service

type CodeLingoServer interface {
	FileFromNode(context.Context, *Node) (*File, error)
	// Lists available lexicons
	ListLexicons(context.Context, *ListLexiconsRequest) (*ListLexiconsReply, error)
	ListFacts(context.Context, *ListFactsRequest) (*FactList, error)
	QueryFromOffset(context.Context, *QueryFromOffsetRequest) (*QueryFromOffsetReply, error)
	DescribeFact(context.Context, *DescribeFactRequest) (*DescribeFactReply, error)
	// Return the latest client version for this platform
	LatestClientVersion(context.Context, *LatestClientVersionRequest) (*LatestClientVersionReply, error)
}

func RegisterCodeLingoServer(s *grpc.Server, srv CodeLingoServer) {
	s.RegisterService(&_CodeLingo_serviceDesc, srv)
}

func _CodeLingo_FileFromNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Node)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).FileFromNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/FileFromNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).FileFromNode(ctx, req.(*Node))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListLexicons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLexiconsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListLexicons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/ListLexicons",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListLexicons(ctx, req.(*ListLexiconsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_ListFacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).ListFacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/ListFacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).ListFacts(ctx, req.(*ListFactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_QueryFromOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFromOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).QueryFromOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/QueryFromOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).QueryFromOffset(ctx, req.(*QueryFromOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_DescribeFact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeFactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).DescribeFact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/DescribeFact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).DescribeFact(ctx, req.(*DescribeFactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeLingo_LatestClientVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestClientVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.CodeLingo/LatestClientVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeLingoServer).LatestClientVersion(ctx, req.(*LatestClientVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CodeLingo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.CodeLingo",
	HandlerType: (*CodeLingoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FileFromNode",
			Handler:    _CodeLingo_FileFromNode_Handler,
		},
		{
			MethodName: "ListLexicons",
			Handler:    _CodeLingo_ListLexicons_Handler,
		},
		{
			MethodName: "ListFacts",
			Handler:    _CodeLingo_ListFacts_Handler,
		},
		{
			MethodName: "QueryFromOffset",
			Handler:    _CodeLingo_QueryFromOffset_Handler,
		},
		{
			MethodName: "DescribeFact",
			Handler:    _CodeLingo_DescribeFact_Handler,
		},
		{
			MethodName: "LatestClientVersion",
			Handler:    _CodeLingo_LatestClientVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "github.com/codelingo/rpc/service/codelingo.proto",
}

func init() { proto.RegisterFile("github.com/codelingo/rpc/service/codelingo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xb5, 0xe3, 0xa4, 0x49, 0x26, 0x45, 0x6d, 0xb6, 0xa1, 0x32, 0x56, 0x11, 0x61, 0x91, 0xa0,
	0x42, 0x28, 0x81, 0xc0, 0x01, 0x81, 0x84, 0x2a, 0x0a, 0x25, 0x2a, 0x51, 0x01, 0x57, 0xea, 0x15,
	0x39, 0xf6, 0xa6, 0x5d, 0xd5, 0xb1, 0xcd, 0xee, 0xa6, 0x34, 0x77, 0x6e, 0x5c, 0xf9, 0x26, 0x3e,
	0x86, 0xaf, 0x40, 0xbb, 0x5e, 0x3b, 0x76, 0x92, 0x72, 0xe2, 0x36, 0x33, 0xfb, 0xf4, 0x76, 0xe6,
	0xbd, 0xf5, 0x18, 0x9e, 0x9e, 0x53, 0x71, 0x31, 0x1b, 0xf7, 0xfc, 0x78, 0xda, 0xf7, 0xe3, 0x80,
	0x84, 0x34, 0x3a, 0x8f, 0xfb, 0x2c, 0xf1, 0xfb, 0x9c, 0xb0, 0x2b, 0xea, 0x93, 0x45, 0xb5, 0x97,
	0xb0, 0x58, 0xc4, 0xa8, 0xae, 0x0f, 0xb0, 0x0d, 0xd5, 0x93, 0x38, 0x20, 0x68, 0x1b, 0xac, 0x19,
	0x0d, 0x6c, 0xb3, 0x6b, 0xee, 0x37, 0x5d, 0x19, 0x62, 0x0c, 0xd5, 0x23, 0x1a, 0x12, 0xe4, 0x40,
	0x63, 0x42, 0x43, 0x12, 0x79, 0x53, 0xa2, 0x8f, 0xf3, 0x1c, 0x4f, 0x61, 0xe7, 0x1d, 0xe1, 0x3e,
	0xa3, 0x63, 0x72, 0xe4, 0xf9, 0xc2, 0x25, 0xdf, 0x66, 0x84, 0x0b, 0xd4, 0x81, 0x5a, 0xfc, 0x3d,
	0x22, 0x4c, 0xe3, 0xd3, 0x04, 0x21, 0xa8, 0x2a, 0x92, 0x8a, 0x2a, 0xaa, 0x18, 0xd9, 0x50, 0xbf,
	0x22, 0x8c, 0xd3, 0x38, 0xb2, 0x2d, 0x55, 0xce, 0x52, 0x89, 0x9e, 0x78, 0xbe, 0xb0, 0xab, 0x29,
	0x5a, 0xc6, 0xf8, 0x87, 0x09, 0xed, 0xf2, 0x7d, 0x49, 0x38, 0x47, 0x5d, 0x68, 0x05, 0xaa, 0x98,
	0x08, 0xc9, 0x93, 0xde, 0x59, 0x2c, 0xc9, 0x11, 0xc8, 0xb5, 0x37, 0x4d, 0x42, 0xc2, 0xf5, 0xed,
	0x79, 0x8e, 0x9e, 0x01, 0x24, 0x2c, 0x4e, 0x08, 0x13, 0x94, 0x70, 0xdb, 0xea, 0x5a, 0xfb, 0xad,
	0x41, 0xbb, 0xa7, 0xe5, 0xe9, 0x7d, 0x4e, 0x8f, 0xe6, 0x6e, 0x01, 0x84, 0x0f, 0xa0, 0x91, 0xd5,
	0xf3, 0xa1, 0xcc, 0xc2, 0x50, 0x4b, 0x0d, 0x55, 0x56, 0x1a, 0xc2, 0xbf, 0x4c, 0xd8, 0xfd, 0x32,
	0x23, 0x6c, 0x7e, 0xc4, 0xe2, 0xe9, 0xa7, 0xc9, 0x84, 0x93, 0x5c, 0x3b, 0x04, 0xd5, 0xd0, 0x8b,
	0xce, 0x33, 0x42, 0x19, 0x4b, 0x73, 0x02, 0xca, 0x34, 0x91, 0x0c, 0x4b, 0xa6, 0x58, 0x65, 0x53,
	0x24, 0x9a, 0x33, 0x5f, 0x0b, 0x27, 0x43, 0xe9, 0x07, 0x17, 0x1e, 0x13, 0x76, 0xad, 0x6b, 0xee,
	0x5b, 0x6e, 0x9a, 0x48, 0x1c, 0x89, 0x02, 0x7b, 0x43, 0xd5, 0x64, 0x88, 0xdf, 0x40, 0x67, 0xa5,
	0x2b, 0xa9, 0xf0, 0x43, 0xa8, 0x49, 0xfd, 0xb9, 0x6d, 0x2a, 0x79, 0xb6, 0x73, 0x79, 0x3e, 0x90,
	0x48, 0xf9, 0x90, 0x1e, 0xe3, 0x3f, 0x26, 0xd4, 0x75, 0x49, 0x75, 0xe8, 0xf9, 0xe2, 0xa4, 0xf8,
	0x6c, 0x74, 0x8e, 0x0e, 0x4a, 0x9a, 0x57, 0x14, 0x69, 0x77, 0x99, 0x34, 0xd3, 0x9e, 0x12, 0xfe,
	0x3e, 0x12, 0xac, 0x64, 0x01, 0x7a, 0x02, 0x0d, 0xff, 0x82, 0x86, 0x01, 0x23, 0x91, 0xf6, 0x6c,
	0xb5, 0xa9, 0x1c, 0xe1, 0x9c, 0xc2, 0xd6, 0x12, 0x99, 0x1c, 0xfe, 0x92, 0xcc, 0xb3, 0xf7, 0x7e,
	0x49, 0xe6, 0xe8, 0x31, 0xd4, 0xae, 0xbc, 0x70, 0x96, 0xbe, 0xcf, 0xd6, 0xa0, 0x53, 0xe4, 0xcb,
	0x9f, 0x41, 0x0a, 0x79, 0x55, 0x79, 0x69, 0x62, 0x06, 0xad, 0xc2, 0x09, 0xb2, 0x61, 0x83, 0x0b,
	0x46, 0x33, 0xe7, 0x86, 0x86, 0xab, 0x73, 0x84, 0xc0, 0xa2, 0x91, 0x50, 0xb4, 0xd6, 0xd0, 0x70,
	0x65, 0x82, 0x76, 0xa1, 0x36, 0x09, 0x63, 0x4f, 0x28, 0xf3, 0x2a, 0x43, 0xc3, 0x4d, 0x53, 0xd4,
	0x81, 0xea, 0x38, 0x8e, 0x43, 0x65, 0x5e, 0x63, 0x68, 0xb8, 0x2a, 0x7b, 0x5b, 0xd7, 0xad, 0xe1,
	0x33, 0xd8, 0x1e, 0x51, 0x2e, 0xe4, 0x78, 0xfc, 0x3f, 0x7e, 0x6c, 0xf8, 0xa7, 0x09, 0x0d, 0x49,
	0x2a, 0xc9, 0xd1, 0xa0, 0xec, 0xf6, 0x5e, 0x2e, 0x44, 0x86, 0x50, 0x81, 0x36, 0x25, 0x85, 0x3a,
	0x1f, 0x01, 0x16, 0xc5, 0x35, 0xe2, 0x3e, 0x2a, 0x8b, 0xbb, 0xf8, 0xc0, 0x0e, 0xb5, 0x47, 0x45,
	0x65, 0xbb, 0xd0, 0xc8, 0xca, 0x72, 0x3a, 0x65, 0xa3, 0x6a, 0xa6, 0xe9, 0xa6, 0x09, 0xbe, 0x0d,
	0x3b, 0xb2, 0x91, 0x11, 0xb9, 0xa6, 0x7e, 0x1c, 0x65, 0x52, 0xe0, 0x3e, 0xb4, 0xcb, 0x65, 0xf9,
	0x78, 0x1d, 0x68, 0x84, 0xba, 0xa0, 0x49, 0xf2, 0x1c, 0xef, 0x81, 0x33, 0xf2, 0x04, 0xe1, 0xe2,
	0x30, 0xa4, 0x24, 0x12, 0x67, 0xa9, 0x1c, 0x19, 0xdd, 0x0b, 0xb0, 0xd7, 0x9e, 0x4a, 0xd6, 0x82,
	0x96, 0x66, 0x49, 0xcb, 0xc1, 0x6f, 0x0b, 0x9a, 0x87, 0x71, 0x40, 0x46, 0x72, 0xdd, 0xa2, 0x1e,
	0x6c, 0xca, 0x2d, 0x2a, 0xbf, 0x28, 0xb5, 0x67, 0x6f, 0xe5, 0x93, 0xcb, 0xd4, 0x59, 0xa4, 0x12,
	0x85, 0x0d, 0x74, 0x0c, 0x9b, 0xc5, 0x11, 0xd0, 0x42, 0xfd, 0x35, 0x03, 0x3b, 0xce, 0x0d, 0xa7,
	0x49, 0x38, 0xc7, 0x06, 0x7a, 0x0d, 0xcd, 0xfc, 0xb5, 0xa0, 0x3b, 0x25, 0x68, 0xf1, 0x05, 0x39,
	0xed, 0x15, 0x87, 0xb1, 0x81, 0x4e, 0x61, 0x6b, 0x69, 0x17, 0xa0, 0x7b, 0x39, 0x6e, 0xfd, 0xee,
	0x72, 0xee, 0xde, 0x0c, 0x48, 0x3b, 0x3a, 0x86, 0xcd, 0xe2, 0xfe, 0x2e, 0x4c, 0xb7, 0xe6, 0x37,
	0x52, 0x98, 0x6e, 0x65, 0xe9, 0x63, 0x03, 0x7d, 0x85, 0x9d, 0x35, 0xee, 0xa0, 0x07, 0x8b, 0x39,
	0x6f, 0x74, 0xd6, 0xb9, 0xff, 0x6f, 0x90, 0xba, 0x60, 0xbc, 0xa1, 0x7e, 0x95, 0xcf, 0xff, 0x06,
	0x00, 0x00, 0xff, 0xff, 0x9d, 0x7b, 0x02, 0x24, 0x5e, 0x07, 0x00, 0x00,
}
